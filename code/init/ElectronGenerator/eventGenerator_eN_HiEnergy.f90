!******************************************************************************
!****m* /eventGenerator_eN_HiEnergy
! NAME
! module eventGenerator_eN_HiEnergy
!
! PURPOSE
! This module includes initilization routines for high energetic electron
! induced events
!
!******************************************************************************
module eventGenerator_eN_HiEnergy

  use idTable, only:nres

  private

  public :: eventGen_eN_HiEnergy
  public :: HighEnergyThreshold
  public :: ReadHiGammaNucleus

  !****************************************************************************
  !****g* eventGenerator_eN_HiEnergy/DoDiffr
  ! SOURCE
  !
  logical,save :: DoDiffr=.true.
  !
  ! PURPOSE
  ! flag: Generate diffractive events
  !****************************************************************************

  !****************************************************************************
  !****g* eventGenerator_eN_HiEnergy/useVMD_VM
  ! SOURCE
  !
  logical,dimension(4),save :: useVMD_VM = .true.
  !
  ! PURPOSE
  ! These flags can be used to switch on/off some VM in the VMD description
  ! of the events generated by "transitionevent"
  ! NOTES
  ! * The VMD events of PYTHIA are not affected. (We could change this!)
  !****************************************************************************

  !****************************************************************************
  !****g* eventGenerator_eN_HiEnergy/DoLowEv
  ! SOURCE
  !
  logical,save :: DoLowEv=.true.
  !
  ! PURPOSE
  ! If this flag is set true, then for W_free<HighEnergyThreshold we will
  ! call the low energy model routines.
  !****************************************************************************


  !****************************************************************************
  !****g* eventGenerator_eN_HiEnergy/DoTransEv
  ! SOURCE
  !
  logical,save :: DoTransEv=.false.
  !
  ! PURPOSE
  ! flag: use transitionEvent in order to replace PYTHIA events by
  ! events where we give the cross section explicitely and do the remaining
  ! stuff by FRITIOF
  ! NOTES
  ! this replaces the flag "FRITIOF" in the namelists "HiLeptonNucleus"
  ! and "HiPhotonNucleus"
  !****************************************************************************

  !****************************************************************************
  !****g* eventGenerator_eN_HiEnergy/useHermesPythiaPars
  ! SOURCE
  !
  logical,save :: useHermesPythiaPars=.false.
  !
  ! PURPOSE
  ! flag: Use "PYTHIA tuning done by HERMES collab"
  !****************************************************************************

  !****************************************************************************
  !****g* eventGenerator_eN_HiEnergy/PYTHIAthresh
  ! SOURCE
  !
  real,   save :: PYTHIAthresh=2.0
  ! PURPOSE
  ! Below this value for W, PYTHIA is not used to generate (G)VMD events
  !
  ! NOTES
  ! This value is transferred to PyVP.f.
  ! you can access this value by the function "GetPYTHIAthresh()".
  !****************************************************************************

  !****************************************************************************
  !****g* eventGenerator_eN_HiEnergy/DoToyModel_pi
  ! SOURCE
  !
  logical,save :: DoToyModel_pi=.false.
  !
  ! PURPOSE
  ! flag: Use a Toy model instead of realistic event generation.
  ! Only a single pion is generated
  !****************************************************************************

  !****************************************************************************
  !****g* eventGenerator_eN_HiEnergy/DoToyModel_rho
  ! SOURCE
  !
  logical,save :: DoToyModel_rho=.false.
  !
  ! PURPOSE
  ! flag: Use a Toy model instead of realistic event generation
  ! Only rho0 N events are generated.
  !
  ! Additional assumptions: (c.f.UseFormTime_ToyModel_rho)
  ! * tau_F = 0
  ! * tau_F = m with t_F = E (boost according E/m, not E_string/M_string)
  !
  ! In the latter case we suffer also the following simplifications:
  ! * no Q2 dependance
  ! * XS starts with n_L/n = 0.5 (should be 0.66 for the nucleon)
  !****************************************************************************

  !****************************************************************************
  !****g* eventGenerator_eN_HiEnergy/UseFormTime_ToyModel_rho
  ! SOURCE
  !
  logical,save :: UseFormTime_ToyModel_rho=.false.
  !
  ! PURPOSE
  ! flag: if .true., we set the formation times of the particles produced
  ! in the ToyModel_rho equals to the energy of the particle (t_f/fm=E/GeV)
  ! representing the assumption tau_f/fm = m/GeV plus a boost according E/m.
  ! (Otherwise the formation time is set to zero.)
  !****************************************************************************

  !****************************************************************************
  !****ig* eventGenerator_eN_HiEnergy/HighEnergyThreshold
  ! SOURCE
  !
  real,parameter :: HighEnergyThreshold=2.0
  !
  ! PURPOSE
  ! flag: minimal free energy, where HiEnergy routine should be called
  !****************************************************************************

  !****************************************************************************
  !****g* eventGenerator_eN_HiEnergy/useRes
  ! SOURCE
  logical,save,dimension(2:nres+1) :: useRes=.true.
  !
  ! PURPOSE
  ! Switch for including/excluding specific resonances
  !****************************************************************************

  !****************************************************************************
  !****g* eventGenerator_eN_HiEnergy/allowRes
  ! SOURCE
  logical,save :: allowRes=.true.
  !
  ! PURPOSE
  ! Switch for including/excluding resonance contribution.
  !
  ! If this is set to .true., 1pion events will just be generated as for the
  ! background, but according the full MAID cross section (if at all)
  !****************************************************************************

  !****************************************************************************
  !****g* eventGenerator_eN_HiEnergy/allow1pi
  ! SOURCE
  logical,save :: allow1pi=.true.
  !
  ! PURPOSE
  ! Switch for including/excluding 1pion contribution.
  !
  ! Depending on the switch allowRes, 1 pion events will be done
  ! according the full cross section or just as a background.
  !****************************************************************************

  !****************************************************************************
  !****g* eventGenerator_eN_HiEnergy/allow2piBack
  ! SOURCE
  logical,save :: allow2piBack=.true.
  !
  ! PURPOSE
  ! Switch for including/excluding additional 2pion background.
  !****************************************************************************

  !****************************************************************************
  !****g* eventGenerator_eN_HiEnergy/allowDIS
  ! SOURCE
  logical,save :: allowDIS=.true.
  !
  ! PURPOSE
  ! Switch for including/excluding DIS contribution
  !****************************************************************************

  !****************************************************************************
  !****g* eventGenerator_eN_HiEnergy/allowVMDrho
  ! SOURCE
  logical,save :: allowVMDrho=.true.
  !
  ! PURPOSE
  ! Switch for including/excluding the VMD gamma N -> rho0 N contribution
  !****************************************************************************

  !****************************************************************************
  !****g* eventGenerator_eN_HiEnergy/allow2p2hQE
  ! SOURCE
  logical,save :: allow2p2hQE=.false.
  !
  ! PURPOSE
  ! Switch for including/excluding the 2p2h QE contribution
  !****************************************************************************

  !****************************************************************************
  !****g* eventGenerator_eN_HiEnergy/allow2p2hDelta
  ! SOURCE
  logical,save :: allow2p2hDelta=.false.
  !
  ! PURPOSE
  ! Switch for including/excluding the 2p2h Delta contribution
  !****************************************************************************

  !****************************************************************************
  !****g* eventGenerator_eN_HiEnergy/DoExclPiModel
  ! SOURCE
  !
  logical,save :: DoExclPiModel=.false.
  !
  ! PURPOSE
  ! flag: Use a model for exclusive pion production. Only those events are
  ! generated
  !****************************************************************************

  !****************************************************************************
  !****g* eventGenerator_eN_HiEnergy/ExclPiCharge
  ! SOURCE
  !
  integer,save :: ExclPiCharge = 1
  !
  ! PURPOSE
  ! variable to specify the charge of the pion produced, if DoExclPiModel
  ! is selected
  !****************************************************************************



  logical,save :: initFlag=.true.


contains

  !****************************************************************************
  !****s* eventGenerator_eN_HiEnergy/ReadHiGammaNucleus
  ! NAME
  ! subroutine ReadHiGammaNucleus
  !
  ! PURPOSE
  ! read the namelist HiGammaNucleus
  !
  !****************************************************************************
  subroutine ReadHiGammaNucleus
    use output
    use PyVP

    implicit none

    integer :: ios,i
    !**************************************************************************
    !****n* eventGenerator_eN_HiEnergy/HiGammaNucleus
    ! PURPOSE
    ! This namelist combines values which are used by
    ! "HiLepton" and "HiPhoton".
    ! It includes:
    ! * DoLowEv
    ! * DoTransEv
    ! * useHermesPythiaPars
    ! * DoDiffr
    ! * PYTHIAthresh
    ! * useVMD_VM
    ! * useRes
    ! * allowRes
    ! * allow1pi
    ! * allow2piBack
    ! * allowDIS
    ! * allowVMDrho
    ! * DoToyModel_pi
    ! * DoToyModel_rho
    ! * UseFormTime_ToyModel_rho
    ! * DoExclPiModel
    ! * ExclPiCharge
    !**************************************************************************
    NAMELIST /HiGammaNucleus/ DoTransEv,useHermesPythiaPars,PYTHIAthresh,&
         & DoDiffr, useVMD_VM, DoToyModel_pi, DoToyModel_rho, DoLowEv,&
         & allowRes,useRes,allow1pi,allow2piBack,allowDIS,allowVMDrho,&
         & allow2p2hQE,allow2p2hDelta,&
         & UseFormTime_ToyModel_rho,&
         & DoExclPiModel,ExclPiCharge

    if (.not.initFlag) return

    call Write_ReadingInput('HiGammaNucleus',0)
    rewind(5)
    read(5,nml=HiGammaNucleus,iostat=ios)
    call Write_ReadingInput('HiGammaNucleus',0,ios)

    write(*,*) '  PYTHIAthresh        =',PYTHIAthresh
    write(*,*) '  useHermesPythiaPars =',useHermesPythiaPars
    write(*,*) '  DoDiffr             =',DoDiffr
    write(*,*) '  DoTransEv           =',DoTransEv,'  (obsolete)'
    write(*,*) '  useVMD_VM           =',useVMD_VM
    write(*,*) '  DoLowEv             =',DoLowEv
    write(*,*)
    write(*,*) '  LowEv: allow Resonance contribution : ',allowRes
    write(*,*) '  LowEv: allow 1pion contribution     : ',allow1pi
    write(*,*) '  LowEv: allow 2pion background       : ',allow2piBack
    write(*,*) '  LowEv: allow DIS contribution       : ',allowDIS
    write(*,*) '  LowEv: allow VMD gamma N -> rho0 N  : ',allowVMDrho
    write(*,*) '  LowEv: allow 2p2h QE                : ',allow2p2hQE
    write(*,*) '  LowEv: allow 2p2h Delta             : ',allow2p2hDelta

    do i=2,nres+1
       if (.not.useRes(i)) then
          write(*,*) '  LowEv: ...Resonance ',i,' is switched off.'
       end if
    end do

    if (DoToyModel_pi) then
       write(*,*)
       write(*,*) '  !!! Attention: using TOY MODEL "single pi" !!!'
       write(*,*)
    end if

    if (DoToyModel_rho) then
       write(*,*)
       write(*,*) '  !!! Attention: using TOY MODEL "rho N" !!!'
       if (UseFormTime_ToyModel_rho) then
          write(*,*) '  !!!            with t_f/fm = E/GeV'
       else
          write(*,*) '  !!!            with t_f/fm = 0'
       end if
       write(*,*)
    end if

    if (DoExclPiModel) then
       write(*,*)
       write(*,*) '  !!! Attention: using Model "Exclusive Pion" !!!'
       write(*,*) '  !!!            charge of pion: ',ExclPiCharge
       write(*,*)
    end if

    call SetPYTHIAthresh(PYTHIAthresh)
    call SetSwitchPythiaHermes(useHermesPythiaPars)

    call Write_ReadingInput('HiGammaNucleus',1)

    initFlag=.false.

  end subroutine ReadHiGammaNucleus


  !****************************************************************************
  !****s* eventGenerator_eN_HiEnergy/eventGen_eN_HiEnergy
  ! NAME
  ! subroutine eventGen_eN_HiEnergy(eNev,firstevent,scaleVMD,
  ! DoPauli,realparticles,
  ! OutPart,channel,FlagOK,XS_tot,XS_Arr,XS_Arr_low)
  !
  ! PURPOSE
  ! This is the main routine for generating a high energy electron nucleon event.
  !
  ! INPUTS
  ! * type(electronNucleon_event) :: eNev     -- electron nucleon kinematics
  ! * integer                     :: firstevent -- number to give in the outpart vector
  ! * real, dimension(1:4)        :: scaleVMD -- scaling of VMD XS (rho, omega, phi, J/psi)
  ! * logical :: DoPauli -- if .true., every event is checked for pauli blocking.
  !   if it is blocked, the corresponding cross section will be set to 0 and the
  !   Monte Carlo decision will neglect this event class. Thus the total cross section
  !   is reduced. Maybe all channel can be closed.
  ! * type(particle),dimension(:,:) :: realParticles -- real particle vector,
  !   only needed for pauli blocking
  !
  ! OUTPUT
  ! * integer                       :: channel -- Chosen Channel
  ! * type(particle), dimension(:)  :: OutPart -- Final State particle vector
  ! * logical                       :: FlagOK  -- .true. if event was successfull
  ! * real                          :: XS_tot  -- total cross section (in mb)
  ! * real, dimension(0:4),OPTIONAL :: XS_Arr  -- cross sections of different channels
  ! * real, dimension(nc),OPTIONAL  :: XS_Arr_low -- cross sections of different low energy channels
  !
  ! NOTES
  ! * The returned Cross Section is (x is lightcone-x, not Bjorken-x!)
  !      dsigma/(fT dx dQ2 dphi)|_(phi=0) = dsigma/(2 pi fT dx dQ2)
  !   and the units are mb
  ! * Comparison with Bosted parametrisation shows, that the values
  !   correspond to their definition of the flux,
  !       \sigma^* = \sigma_T+\epsilon\sigma_L
  !                = \frac{1}{\Gamma} \frac{d\sigma}{dE' d\Omega}
  !    with
  !       \gamma = \frac{\alpha E (W^2-M^2)}{(2\pi)^2 Q^2 M E (1-\epsilon)}
  !    Thus, \sigma^* differs by a factor 2\pi from the definitions (C.36)
  !    in the GiBUU paper. Thus, curves in Fig. C.64 are a factor 2\pi
  !    too high, if one asumes eq.(C.63) to hold.
  !****************************************************************************
  subroutine eventGen_eN_HiEnergy(eNev,firstevent,scaleVMD,DoPauli,realparticles, &
       OutPart,channel,FlagOK,XS_tot,XS_Arr,XS_Arr_low)
    use particleDefinition
    use eN_eventDefinition, only: electronNucleon_event
    use eN_event
    use Coll_gammaN
    use Coll_gammaN_exclPi
    use CallStack
    use eventGenerator_eN_lowEnergy
    use constants, only: pi
    use PythiaSpecFunc, only: Init_VM_Mass

    implicit none

    type(electronNucleon_event), intent(inout):: eNev    ! The incoming electron and nucleon
    integer,                      intent(in)  :: firstevent ! number to give
    integer,                      intent(out) :: channel ! Chosen Channel
    type(particle), dimension(:), intent(out) :: OutPart ! FinalState particles
    logical,                      intent(out) :: FlagOK  ! .true. if finalState was created
    real, dimension(1:4),         intent(in)  :: scaleVMD
    real,                         intent(out) :: XS_tot
    real, dimension(0:4),OPTIONAL,intent(out) :: XS_Arr
    real, dimension(8),  OPTIONAL,intent(out) :: XS_Arr_low
    logical,                      intent(in)  :: DoPauli
    type(particle), intent(in), dimension(:,:):: realParticles

    real :: nu,Q2,W,Wfree,fT

    real, dimension(0:4)  :: Cross
    real, dimension(8)    :: Cross_low
    integer               :: EventClass
    logical, dimension(8) :: doC


    XS_tot = 0
    flagOK = .false.
    if (present(XS_Arr))     XS_Arr = 0.0
    if (present(XS_Arr_low)) XS_Arr_low = 0.0

    call SetOutPartDefaults

    if (DoToyModel_pi) then
       call DoColl_gammaN_toy(eNev,flagOK,outPart)

       channel = 5000
       XS_tot = 1.0
       flagOK = .true.
       return
    end if


    call eNeV_GetKinV(eNev, nu,Q2,W,Wfree,fT=fT)
    ! for the low energy part (and also for excl. pi) we have to convert
    ! dsigma/dE'dOmega (in mub/sr MeV = mb/sr GeV) to
    ! dsigma/dnudQ2 (in mub/GeV^3)
    ! and to divide by the flux in order to get sigma^{gamma*} (in mub)
    ! we collect this here:
    fT = fT/ ( 1e3* pi/(eNev%lepton_out%momentum(0)*eNev%lepton_in%momentum(0)))

    if (DoExclPiModel) then
       call DoColl_gammaN_exclPi(eNev,ExclPiCharge,flagOK,outPart, XS_tot)

       ! since the above routine again relies on intent(out) of the outpart
       ! vector, we are setting again the vector to our 'defaults':
       call SetOutPartDefaults

       ! transfor cross section to sigma*:
       outPart%perWeight = outPart%perWeight / fT
       XS_tot = XS_tot /fT
       channel = 5000
       return
    end if



    if (DoToyModel_rho) then

       doC = (/.false.,.false.,.false.,.false.,.false.,.true.,.false.,.false./)
       call eventGen_eN_lowEnergy(eNev,doC,useRes,DoPauli,realparticles, &
            outPart,channel,flagOK,XS_tot)

       ! since the above routine again relies on intent(out) of the outpart
       ! vector, we are setting again the vector to our 'defaults':
       call SetOutPartDefaults

       ! We have to cheat and claim, that the numbers were guessed:
       call resetNumberGuess(.TRUE.)

       ! Setting formation time, if wished:
       if (UseFormTime_ToyModel_rho) then
          outPart%formationTime = outPart%momentum(0)
          outPart%In_Formation = (outPart%momentum(0).gt.0)
          outPart%scaleCS = 0.5 ! should be 0.66 for the baryon !!!
       end if

       ! transfor cross section to sigma*:
       outPart%perWeight = outPart%perWeight / fT
       XS_tot = XS_tot /fT
       return

    end if


    if (Wfree.lt.HighEnergyThreshold) then
       if (DoLowEv) then

          doC = (/.false.,allowRes,allow1Pi,allow2piBack,allowDIS,allowVMDrho,allow2p2hQE,allow2p2hDelta/)
          call eventGen_eN_lowEnergy(eNev,doC,useRes,DoPauli,realparticles, &
               outPart,channel,flagOK,XS_tot,Cross_low)

          ! since the above routine again relies on intent(out) of the outpart
          ! vector, we are setting again the vector to our 'defaults':
          call SetOutPartDefaults

          ! We have to cheat and claim, that the numbers were guessed:
          call resetNumberGuess(.TRUE.)

          ! transfor cross section to sigma*:
          outPart%perWeight = outPart%perWeight / fT
          XS_tot = XS_tot / fT

          if (present(XS_Arr_low)) then
             XS_Arr_low = Cross_low / fT
          end if

       end if
       return
    end if

    if (.not.eNeV_CheckForDIS(eNev)) return

    !...get Pythia output (this sets also the cross sections)

!    DoColl_gammaN_verbose=.TRUE.
    call Init_VM_Mass(Wfree,eNev%nucleon%position)
    call DoColl_gammaN_Py(eNev,outPart,flagOK, scaleVMD, DoDiffr, Cross,EventClass)
!    call DoColl_gammaN_Py(eNev,outPart,flagOK, scaleVMD, DoDiffr, Cross,EventClass,MinW=5.0)

!    STOP

    if (DoPauli) then
       call TRACEBACK("DoPauli not yet implemented")
    end if

    channel = 2000 + EventClass

!    XS_Resolved = 1000 * (Cross(1)+Cross(3))
    XS_tot      = 1000 * Cross(0) ! in muBarn

    if (present(XS_Arr)) XS_Arr = Cross

    !...if we are above the Pythia threshold: all done
    !   (attention flagOK may be set to false!)

    if (Wfree .ge. PYTHIAthresh) return ! ==> ALL DONE

    call TRACEBACK("Wfree=HighEnergyThreshold...PYTHIAthresh not yet re-implemented.")
    ! see below (genHiPhotonEvent, transitionEvent) how one would have to
    ! reeimplement the stuff

  contains

    subroutine SetOutPartDefaults
      use collisionNumbering, only: pert_numbering
      implicit none
      integer :: number

      OutPart%firstEvent = firstEvent

      OutPart%position(1) = eNev%nucleon%position(1)
      OutPart%position(2) = eNev%nucleon%position(2)
      OutPart%position(3) = eNev%nucleon%position(3)

      number = pert_numbering(eNev%nucleon)
      OutPart%event(1) = number
      OutPart%event(2) = number

      OutPart%perturbative=.true.
      OutPart%productionTime= 0
      OutPart%formationTime = -999

    end subroutine SetOutPartDefaults

  end subroutine eventGen_eN_HiEnergy


!!$  !*************************************************************************
!!$  !****s* initHiPhoton/genHiPhotonEvent
!!$  ! NAME
!!$  ! subroutine genHiPhotonEvent(eNev,scaleVMD,flagOK,outPart,XS_tot,XS_Arr)
!!$  !
!!$  ! PURPOSE
!!$  ! given the kinematics of a electron nucleon event, this
!!$  ! routine generates a particle vector of outgoing particles.
!!$  ! Additionaly the total cros section is determined.
!!$  !
!!$  ! 1) If W<2GeV, everything fails!
!!$  !
!!$  ! 2) If W>"PYTHIAthresh" (e.g. 3GeV) everything is done by PYTHIA
!!$  !
!!$  ! 3) "Transition region":
!!$  ! First it tries to generate an event using PYTHIA. (Below
!!$  ! "PYTHIAthresh" only DIS events are generated.)
!!$  ! Then we have to calculate the (relative) VMD and GVMD cross sections
!!$  ! and add them in order to get XS_tot right.
!!$  ! If we return now, the total XS is okay, but all events are of DIS-shape.
!!$  ! If "DoTransEv" is set, VMD events are generated by FRITIOF according
!!$  ! to their relative XS (or the original PYTHIA DIS event is kept).
!!$  !
!!$  ! Events of the kind:
!!$  ! * gamma N -> V N
!!$  ! * gamma N -> V N pi
!!$  ! * gamma N -> V Delta
!!$  ! * gamma N -> Lambda K, Sigma K, K+ K- N
!!$  ! are excluded from the FRITIOF machinery and done "by hand"
!!$  !
!!$  !
!!$  ! INPUTS
!!$  ! * type(electronNucleon_event) :: eNev     -- electron nucleon kinematics
!!$  ! * real, dimension(1:4)        :: scaleVMD -- scaling of VMD XS (rho, omega, phi, J/psi)
!!$  !
!!$  ! OUTPUT
!!$  ! * type(particle),dimension(:) :: outPart  -- outgoing particles
!!$  ! * logical                     :: flagOK   -- .FALSE. on failure
!!$  ! * real                        :: XS_Tot   -- total cross section for this
!!$  !   event, i.e. for these kinematical variables
!!$  ! * real, dimension(0:4),OPTIONAL :: XS_Arr   -- array of cross sections,
!!$  !   cf. DoColl_gammaN_Py
!!$  !
!!$  ! NOTES
!!$  ! * This is one of the main HiEnergy Photon or Lepton routines.
!!$  ! * we replaced the argument "DoDifr" by the module parameter "DoDiffr";
!!$  !   If set .TRUE., PYTHIA tries to generate diffractive events also.
!!$  !   Here the relative cross sections of the different channels (direct,
!!$  !   VMD,GVMD,DIS) are not given by their parametrisations, but PYTHIA
!!$  !   is somehow in a "learning mode": The values evolve in time...
!!$  ! * The returned Cross Section is (x not Bjorken x!)
!!$  !      dsigma/(fT dx dQ2 dphi)|_(phi=0) = dsigma/(2 pi fT dx dQ2)
!!$  !   and the units are mb
!!$  ! * The full glory of "type(electronNucleon_event)" is not used up to now
!!$  !*************************************************************************
!!$  subroutine genHiPhotonEvent(eNev,scaleVMD,flagOK,outPart,XS_tot,XS_Arr)
!!$
!!$    use Coll_gammaN
!!$    use XS_VMD
!!$    use photonXSections
!!$    use mediumDefinition
!!$    use Coll_gammaN_low
!!$    use CallStack
!!$    use eN_event
!!$
!!$    implicit none
!!$
!!$    type(electronNucleon_event),intent(in)   :: eNev
!!$    type(particle),dimension(:),intent(inout):: outPart
!!$    logical,                    intent(out)  :: flagOK
!!$    real, dimension(1:4),       intent(in)   :: scaleVMD
!!$    real,                       intent(out)  :: XS_Tot
!!$    real, dimension(0:4),OPTIONAL,intent(out):: XS_Arr
!!$
!!$    ! for PYTHIA events:
!!$
!!$    real, dimension(0:4)        :: Cross
!!$    integer                     :: EventClass
!!$
!!$    ! local variables:
!!$
!!$    real,dimension(1:4)         :: Formf
!!$    logical                     :: transEv
!!$    real                        :: XS_Resolved!, XS_Exclusive
!!$    real                        :: hhh
!!$
!!$    type(medium)                :: media
!!$
!!$    real                        :: W,Wfree
!!$    real                        :: Q2
!!$    real                        :: eps
!!$    real, dimension(0:3)        :: pcm
!!$    real, dimension(1:3)        :: beta
!!$
!!$
!!$    XS_tot = 0
!!$
!!$    if (DoToyModel_pi) then
!!$       call DoColl_gammaN_toy(eNev,flagOK,outPart)
!!$       OutPart%perturbative=.true.
!!$       OutPart%productionTime= 0
!!$       OutPart%formationTime = -999
!!$       HiPhotonEventType = 5000
!!$       XS_tot = 1.0
!!$       return
!!$    endif
!!$
!!$    call eNeV_GetKinV(eNev, nu,Q2,W,Wfree)
!!$
!!$    !...only high energy photons
!!$    if ((DoLowEv).and.(Wfree.lt.HighEnergyThreshold)) then
!!$
!!$       call TRACEBACK("DoColl_gammaN_low not yet reimplemented.")
!!$!       call DoColl_gammaN_low(inPart,outPart,flagOK, W,Wfree,Q2,eps, pcm,beta, XS_tot)
!!$
!!$       OutPart%perturbative=.true.
!!$       OutPart%productionTime= 0
!!$       OutPart%formationTime = -999
!!$
!!$       HiPhotonEventType = 5000
!!$
!!$       return
!!$    end if
!!$
!!$    !...get Pythia output (this sets also the cross sections)
!!$
!!$    outPart(:)%number = 0
!!$    call TRACEBACK("DoColl_gammaN_Py not yet reimplemented.")
!!$!    call DoColl_gammaN_Py(inPart,outPart,flagOK, Wfree,Q2,eps,scaleVMD, pcm,beta, DoDiffr, Cross,EventClass)
!!$!    call DoColl_gammaN_Py(inPart,outPart,flagOK, Wfree,Q2,eps,scaleVMD, pcm,beta, DoDiffr, Cross,EventClass,minW=5.0)
!!$
!!$
!!$!    write(*,'(A,5f12.5)') 'Cross:',Cross
!!$
!!$    if (PRESENT(XS_Arr)) XS_Arr = Cross
!!$
!!$
!!$    HiPhotonEventType = 2000 + EventClass
!!$
!!$    XS_Resolved = 1000 * (Cross(1)+Cross(3))
!!$    XS_tot      = 1000 * Cross(0) ! in muBarn
!!$
!!$    !...if we are above the Pythia threshold: all done
!!$    !   (attention flagOK may be set to false!)
!!$
!!$    if(Wfree > GetPYTHIAthresh()) return ! ==> ALL DONE
!!$
!!$    !...we are below the Pythia threshold:
!!$    !...Pythia did only a DIS event; VMD was switched off by hand.
!!$    !...Cross(1) and Cross(3) have to be calculated by hand:
!!$
!!$    call eNeV_GetKinV(eNev, nu,Q2,W,Wfree,eps) ! get 'eps' right
!!$
!!$    call vmd(Wfree,Q2,eps,XSvmd,useVMD_VM)
!!$    call gvmd(Wfree,Q2,eps,XSgvmd,useVMD_VM)
!!$    XS_Typ = XSvmd+XSgvmd
!!$    XS_Resolved = XS_Typ(0)
!!$    XS_tot      = 1000*(Cross(2)+Cross(4)) + XS_Resolved
!!$
!!$    !...If we DO NOT produce the VMD event with Fritiof/Exclusive,
!!$    !...the relative weight of the Pythia DIS event is set to 100%,
!!$    !...i.e. all event types are "simulated" by DIS events.
!!$    !...(A DIS event looks very similar to all the other stuff and
!!$    !...is a good approx.)
!!$
!!$    if (.not.DoTransEv) return ! ==> ALL DONE
!!$
!!$    !...We want to replace the Pythia-DIS-event by a (resolved)Fritiof
!!$    !...or by a Exclusive event:
!!$    !...calculate the corresponding cross sections:
!!$
!!$    call eleformf(Wfree,Q2,eps, Formf)  !... calculate Formfactor
!!$
!!$    call calcXS_gammaN2VN(Wfree, XS_Elast, XS_ElastPlusPi, media) ! sigma(gamma N -> V N)
!!$                                                                  ! sigma(gamma N -> V N pi)
!!$    call calcXS_gammaN2VDelta(Wfree, XS_ElastDelta, media)        ! sigma(gamma N -> V Delta)
!!$
!!$    call calcXS_gammaN2strange(Wfree, XS_Strange)                 ! sigma(gamma N -> Lambda K,Sigma K, K+ K- N)
!!$
!!$    XS_Elast       = XS_Elast       * scaleVMD * Formf
!!$    XS_ElastPlusPi = XS_ElastPlusPi * scaleVMD * Formf
!!$    XS_ElastDelta  = XS_ElastDelta  * scaleVMD * Formf
!!$    XS_Strange     = XS_Strange     * scaleVMD(3) * Formf(3)
!!$
!!$    !XS_Exclusive = SUM(XS_Elast)+SUM(XS_ElastDelta) + SUM(XS_Strange)
!!$    ! Remark: XS_ElastPlusPi is of no further interest!!!
!!$    !         ...            its value is larger than 1.0 !!!
!!$
!!$
!!$    ! perform some corrections:
!!$
!!$    hhh = SUM(XS_Strange)+XS_Elast(3)+XS_ElastDelta(3)-XS_tot
!!$    if (hhh.gt.0.0) then
!!$! !!$       if (hhh.gt.0.1*XS_tot) then
!!$! !!$          write(*,*) 'warning: correction of XS_tot > 10%:',hhh/XS_tot,hhh
!!$! !!$       endif
!!$! !!$       if (hhh.gt.0.1*XS_typ(3)) then
!!$! !!$          write(*,*) 'warning: correction of XS_typ(3) > 10%:',hhh/XS_typ(3),hhh
!!$! !!$       endif
!!$
!!$       XS_Typ(3)   = XS_Typ(3)    + hhh
!!$       XS_Typ(0)   = XS_Typ(0)    + hhh
!!$       XS_Resolved = XS_Resolved  + hhh
!!$       XS_tot      = XS_tot       + hhh
!!$       XSvmd(3)  = XSvmd(3)       + hhh
!!$       XSvmd(0)  = XSvmd(0)       + hhh
!!$    endif
!!$
!!$
!!$!    write(*,'(A,1P,50g12.5)') '~~~~ XS : ', Wfree,Q2,1.*inPart%Charge, &
!!$!            XS_Tot,XS_Resolved/XS_tot,XS_Exclusive/XS_Resolved, &
!!$!            SUM(XS_Elast)/XS_Resolved, SUM(XS_ElastDelta)/XS_Resolved, SUM(XS_Strange)/XS_Resolved
!!$
!!$!    write(*,'(A,1P,50g12.5)') '~~~~ XS : ', Wfree,Q2, XS_Tot,&
!!$!            XS_Typ,XS_Elast,XS_ElastDelta
!!$
!!$! !!$    write(*,'(A,1P,50g12.5)') '~~~~ XS : ', Wfree,Q2, XS_Tot
!!$! !!$    write(*,'(A,1P,50g12.5)') '~~~~ XS : ', Wfree,Q2, XS_Typ
!!$! !!$    write(*,'(A,1P,50g12.5)') '~~~~ XS : ', Wfree,Q2, XSvmd
!!$! !!$    write(*,'(A,1P,50g12.5)') '~~~~ XS : ', Wfree,Q2, XSgvmd
!!$! !!$    write(*,'(A,1P,50g12.5)') '~~~~ XS : ', Wfree,Q2, 0.0, XS_Elast
!!$! !!$    write(*,'(A,1P,50g12.5)') '~~~~ XS : ', Wfree,Q2, 0.0, XS_ElastDelta
!!$! !!$    write(*,'(A,1P,50g12.5)') '~~~~ XS : ', Wfree,Q2, XS_Strange
!!$
!!$
!!$
!!$
!!$!...now replace this event with a Fritiof/exclusive event --- if desired...
!!$
!!$    transEv=.false.
!!$    call TRACEBACK("transitionEvent not yet reimplemented.")
!!$!    if(DoTransEv) &
!!$!         call transitionEvent(inPart,outPart, transEv, Wfree,Q2,eps, XS_tot, pcm,beta,media)
!!$
!!$    if (transEv) then
!!$       if (DoPr(1)) write(*,*) '...PYTHIA event replaced by transitionEvent:',HiPhotonEventType
!!$       flagOK = transEv
!!$
!!$    endif
!!$
!!$
!!$
!!$  end subroutine genHiPhotonEvent
!!$
!!$  !*************************************************************************
!!$  !****s* initHiPhoton/transitionEvent
!!$  ! NAME
!!$  ! subroutine transitionEvent(inPart,outPart, flagOK, W,Q2,eps, XS_tot, pcm,beta,media)
!!$  !
!!$  ! PURPOSE
!!$  ! This routine is called by genHiPhotonEvent and creates non-PYTHIA
!!$  ! events in the transition region W= ??? ... PYTHIAthresh.
!!$  !
!!$  ! The default value is PYTHIAthresh=2 GeV.
!!$  ! (You can set the value by the namelist of your eventtype, if provided.)
!!$  !
!!$  ! NOTES
!!$  ! * it's an internal routine
!!$  ! * The variable W used here corresponds to Wfree in genHiPhotonEvent
!!$  !*************************************************************************
!!$  subroutine transitionEvent(inPart,outPart, flagOK, W,Q2,eps, XS_tot, pcm,beta,media)
!!$
!!$    use twoBodyTools, only : sqrtS_free
!!$    use output
!!$    use random
!!$    use mediumDefinition
!!$    use particleDefinition
!!$    use master_2Body, only : setKinematics
!!$    use propagation, only : updateVelocity
!!$    use hadronformation
!!$
!!$
!!$    implicit none
!!$
!!$    type(particle),             intent(in)   :: inPart   ! incoming nucleon
!!$    type(particle),dimension(:),intent(inout):: outPart  ! outgoing particles
!!$    logical,                    intent(out)  :: flagOK
!!$    real,                       intent(in)   :: W
!!$    real,                       intent(in)   :: Q2
!!$    real,                       intent(in)   :: eps
!!$    real, dimension(0:3),       intent(in)   :: pcm
!!$    real, dimension(1:3),       intent(in)   :: beta
!!$    real,                       intent(in)   :: XS_Tot
!!$    type(medium),               intent(in)   :: media
!!$
!!$    !real,dimension(0:4) :: XS_sum
!!$    real :: pvmd, pQ
!!$    integer :: iTyp, iEvTyp
!!$    integer :: sumID, iRho!,IZ
!!$    integer :: IDbaryon = 100
!!$    integer :: i,nOut, iTry
!!$    logical :: eventOK!,frflag
!!$
!!$    type(particle),dimension(2) :: pair  ! 'ingoing' particles in exclusive event
!!$    real :: srtS, srtS_vacuum
!!$    real, dimension(1:3) :: betaToLRF
!!$
!!$    COMMON/QYJETS/N,NPAD,K(4000,5),P(4000,5),V(4000,5)
!!$    integer N,NPAD,K
!!$    double precision P,V
!!$    SAVE /QYJETS/
!!$
!!$    common /DataGJV/ Arr(3,4,200),EArr(6,200),verb,AtOrigin
!!$    ! Arr(3,4,nArrMax),    ! 3* 4D-Vertizes
!!$    ! EArr(6,nArrMax),     ! errFlag, rank
!!$    ! verb,                ! verbosity
!!$    ! AtOrigin             ! treatment of outmost prod points
!!$    double precision Arr
!!$    integer EArr
!!$    integer verb
!!$    logical AtOrigin
!!$    save /DataGJV/
!!$
!!$
!!$    flagOK=.false.
!!$
!!$    pVMD=rn() * XS_tot
!!$    if (pVMD >= XS_Typ(0)) return ! keep Pythia event
!!$
!!$
!!$!    write(*,*) '...doing, W=',W
!!$    flagOK=.true.
!!$
!!$    call ResetNumberGuess()
!!$
!!$
!!$!...select vector meson:
!!$
!!$    if (pvmd.le.XS_Typ(1)) then
!!$       iTyp = 1
!!$    else if (pvmd.le.XS_Typ(1)+XS_Typ(2)) then
!!$       iTyp = 2
!!$    else if (pvmd.le.XS_Typ(1)+XS_Typ(2)+XS_Typ(3)) then
!!$       iTyp = 3
!!$    else if (pvmd.le.XS_Typ(1)+XS_Typ(2)+XS_Typ(3)+XS_Typ(4)) then
!!$       if (W.gt.4.04) then
!!$          iTyp = 4
!!$       else
!!$          iTyp = 1
!!$       endif
!!$    else
!!$       write(*,*) XS_tot,pVMD
!!$       write(*,*) XS_Typ
!!$       write(*,*) 'Error in transitionEvent'
!!$       stop
!!$    endif
!!$
!!$!...select event type:
!!$
!!$    pVMD=rn()*XS_tot
!!$
!!$    if (pVMD.le.SUM(XS_Strange)) then
!!$       if (pVMD .le. XS_Strange(1)) then
!!$          iEvTyp = 3
!!$       else if (pVMD .le. XS_Strange(1)+XS_Strange(2)) then
!!$          iEvTyp = 4
!!$       else
!!$          iEvTyp = 5
!!$       endif
!!$
!!$    else
!!$       pVMD=rn()*XS_Typ(iTyp)
!!$
!!$       if (pVMD.le.XS_Elast(iTyp)) then
!!$          iEvTyp=1 ! gamma N -> V N
!!$       else if (pVMD.le.XS_Elast(iTyp)+XS_ElastDelta(iTyp)) then
!!$          iEvTyp=2 ! gamma N -> V Delta
!!$       else
!!$          iEvTyp=0 ! gamma N -> Fritiof
!!$       endif
!!$    endif
!!$
!!$
!!$    if (iEvTyp.gt.0) then
!!$       ! (0a) Setting incoming particles
!!$
!!$       pair(2)%ID     = 101+2*iTyp ! MESON
!!$       pair(2)%charge = 0
!!$
!!$       pair(2)%momentum(3) = (W**2-pair(1)%mass**2)/(2*W)
!!$       pair(2)%momentum(0) = pair(2)%momentum(3)
!!$
!!$       pair(1) = inPart            ! BARYON
!!$
!!$       pair(1)%momentum(1:3) = -pair(2)%momentum(1:3)
!!$       pair(1)%momentum(0)   = sqrt(pair(1)%mass**2 + pair(1)%momentum(3)**2)
!!$
!!$
!!$       ! (1) Evaluate Sqrt(s)
!!$       srtS = W
!!$
!!$       ! (2) Define Sqrt(s) in the vacuum
!!$       srtS_vacuum=sqrtS_free(pair)
!!$
!!$       betaToLRF=0.
!!$
!!$       OutPart%perturbative=.true.
!!$       OutPart%productionTime= 0
!!$       OutPart%formationTime = -999
!!$       OutPart%antiparticle = .false.
!!$
!!$       ! (0b) Store Q2 in mass of vector meson
!!$       pair(2)%mass = -Q2 ! ATTENTION
!!$
!!$       HiPhotonEventType = iEvTyp*100
!!$
!!$    endif
!!$
!!$    select case(iEvTyp)
!!$
!!$    case (0) !=== FRITIOF Event ===
!!$
!!$       iTry = 0
!!$       do
!!$          iTry = iTry+1
!!$          eventOK = .false.
!!$
!!$          if (iTry >= 100) then
!!$             if (DoPR(3)) write(*,*) 'transitionEvent: iTry=100!  iTyp,W = ',iTyp,W,InPart%number
!!$             call QYLIST(2)
!!$             call writeFritiofCommons(9001)
!!$             exit
!!$          end if
!!$
!!$          call DoColl_gammaN_Fr(inPart,outPart,eventOK, W,Q2,eps, pcm,beta, iTyp)
!!$          if (.not.eventOK) cycle
!!$
!!$          nOut = 0
!!$          do i=1,size(outPart)
!!$             if (outPart(i)%ID > 0) nOut = nOut+1
!!$          enddo
!!$
!!$          ! the following exclusive events are treated seperately:
!!$
!!$          select case(nOut)
!!$          case (2)
!!$             select case (min(outPart(1)%ID,outPart(2)%ID))
!!$             case (-1:0)
!!$                write(*,*) 'Ooops in transitionEvent (2)'
!!$                stop
!!$
!!$             case(1)
!!$                sumID = SUM(outPart(1:2)%ID) - IDbaryon
!!$                iRho = 1
!!$                if (sumID.eq.2 .or. sumID.eq.4) then
!!$                   if (outPart(1)%ID.eq.1) then
!!$                      iRho = inPart%charge - outPart(1)%charge
!!$                   else
!!$                      iRho = inPart%charge - outPart(2)%charge
!!$                   endif
!!$                endif
!!$                if ((iRho.eq.0) .or. sumID.eq.6 .or. sumID.eq.8 .or. sumID.eq.10) &
!!$                     & cycle !---> no V+N,pi0+N
!!$
!!$             case (2)
!!$                sumID = SUM(outPart(1:2)%ID) - IDbaryon
!!$                iRho = 1
!!$                if (sumID.eq.3 .or. sumID.eq.5) then
!!$                   if (outPart(1)%ID.eq.2) then
!!$                      iRho = inPart%charge - outPart(1)%charge
!!$                   else
!!$                      iRho = inPart%charge - outPart(2)%charge
!!$                   endif
!!$                endif
!!$                if ((iRho.eq.0) .or. sumID.eq.7 .or. sumID.eq.9 .or. sumID.eq.11) &
!!$                   &  cycle !---> no V+Delta,pi0+Delta
!!$             end select ! min(ID)
!!$
!!$          case (3)
!!$             select case (min(outPart(1)%ID,outPart(2)%ID,outPart(3)%ID))
!!$             case (0)
!!$                write(*,*) 'Ooops in transitionEvent (3)'
!!$                stop
!!$
!!$             case (1)
!!$                sumID = SUM(outPart(1:3)%ID) - 2*IDbaryon
!!$                if(sumID.eq.22.and.(outPart(1)%ID.eq.110 .or. outPart(2)%ID.eq.110 .or. outPart(3)%ID.eq.110)) &
!!$                     cycle !---> no excl. K+Kbar+N
!!$             end select
!!$
!!$          end select
!!$
!!$          ! leave the loop:
!!$          exit
!!$       end do
!!$
!!$       HiPhotonEventType = 1000
!!$
!!$    case (1,2) !=== V N, V Delta ===
!!$
!!$       ! (4a) Intialize output
!!$       OutPart(1)%ID = iEvTyp ! N or Delta
!!$       OutPart(2)%ID = pair(2)%ID
!!$
!!$       OutPart(1:2)%charge = pair(1:2)%charge
!!$
!!$       HiPhotonEventType = HiPhotonEventType+iTyp
!!$
!!$    case (3) !=== Lambda K ===
!!$
!!$       ! (4a) Intialize output
!!$       OutPart(1)%ID = 32   ! Lambda
!!$       OutPart(2)%ID = 110  ! K
!!$
!!$       OutPart(1)%charge = 0
!!$       OutPart(2)%charge = pair(1)%charge
!!$
!!$    case (4) !=== Sigma K ===
!!$
!!$       ! (4a) Intialize output
!!$       OutPart(1)%ID = 33   ! Sigma
!!$       OutPart(2)%ID = 110  ! K
!!$
!!$       OutPart(2)%charge = nint(rn())
!!$       OutPart(1)%charge = pair(1)%charge-OutPart(2)%charge
!!$
!!$
!!$    case (5) !=== K+ K- N ===
!!$
!!$       OutPart(1)%ID = 1    ! N
!!$       OutPart(2)%ID = 110  ! Kaon
!!$       OutPart(3)%ID = 111  ! KaonBar
!!$
!!$       pQ = rn()
!!$       if (pQ .lt. 1.0/3.0) then
!!$          OutPart(1)%charge = pair(1)%charge
!!$          OutPart(2)%charge = 1
!!$          OutPart(3)%charge = -1
!!$       else if (pQ .lt. 2.0/3.0) then
!!$          OutPart(1)%charge = pair(1)%charge
!!$          OutPart(2)%charge = 0
!!$          OutPart(3)%charge = 0
!!$       else
!!$          OutPart(1)%charge = 1 - pair(1)%charge
!!$          OutPart(2)%charge = pair(1)%charge
!!$          OutPart(3)%charge = pair(1)%charge - 1
!!$       endif
!!$
!!$    case DEFAULT !
!!$
!!$       write(*,*) 'other...'
!!$       stop
!!$
!!$    end select
!!$
!!$    select case(iEvTyp)
!!$
!!$    case (1,2,3,4) !=== exclusive event, 2 particle final state ===
!!$
!!$       call setNumberGuess(OutPart(1))
!!$       call setNumberGuess(OutPart(2))
!!$
!!$       ! (5) set final state information
!!$
!!$       call setKinematics(srtS,srtS_vacuum,pcm,betaToLRF,beta,media,pair,OutPart(1:2),eventOK)
!!$       OutPart%in_Formation= .TRUE.
!!$       OutPart%scaleCS = getTauFormaFak()
!!$
!!$       ! (5a) set times and formation flag
!!$
!!$       do i=1,2
!!$          P(i,1:3) = OutPart(i)%momentum(1:3)
!!$          P(i,4)   = OutPart(i)%momentum(0)
!!$          P(i,5)   = OutPart(i)%mass
!!$          EArr(1,i) = 1 ! ok
!!$          EArr(3,i) = 6 ! "from Doku"
!!$       enddo
!!$
!!$       call Guess2BodyTimes(0,1,2)
!!$
!!$       do i=1,2
!!$          call SetJSVFormation(OutPart(i),i, Q2, 99)
!!$       enddo
!!$
!!$!       OutPart%formationTime = 0.0 ! ATTENTION !!!!
!!$
!!$
!!$       call updateVelocity(OutPart)
!!$
!!$!       call WriteParticle(6,1,1,OutPart(1))
!!$!       call WriteParticle(6,1,2,OutPart(2))
!!$
!!$    case (5) !=== exclusive event, 3 particle final state ===
!!$
!!$       call setNumberGuess(OutPart(1))
!!$       call setNumberGuess(OutPart(2))
!!$       call setNumberGuess(OutPart(3))
!!$
!!$       ! (5) set final state information
!!$
!!$       call setKinematics(srtS,srtS_vacuum,pcm,betaToLRF,beta,media,pair,OutPart(1:3),eventOK)
!!$       OutPart%in_Formation= .TRUE.
!!$       OutPart%scaleCS = getTauFormaFak()
!!$       Outpart(2:3)%scaleCS = 0.5*Outpart(1:2)%scaleCS ! Kaons have only 1 leading quark
!!$
!!$       do i=1,3
!!$          call SetJSVFormation(OutPart(i),i, Q2, 99)
!!$       enddo
!!$
!!$       call updateVelocity(OutPart)
!!$
!!$! !!$       write(*,*) '!=== exclusive event, 3 particle final state ==='
!!$! !!$       call WriteParticle(6,1,1,OutPart(1))
!!$! !!$       call WriteParticle(6,1,2,OutPart(2))
!!$! !!$       call WriteParticle(6,1,3,OutPart(3))
!!$
!!$    end select
!!$
!!$
!!$  end subroutine transitionEvent



end module eventGenerator_eN_HiEnergy
